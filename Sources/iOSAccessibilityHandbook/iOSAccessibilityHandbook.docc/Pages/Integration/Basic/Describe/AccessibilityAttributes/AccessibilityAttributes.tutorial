@Tutorial(time: 30) {
    
    @Intro(title: "Describing Interface for Accessibility API") {
        In this tutorial we're going to discuss unquestionably *the most* important thing to make an interface accessible — properly **describe its elements** for both users and assistive technology. 

        ## Importance of data exposure
        **Accessible description** of elements allows Accessibility API to deal with the interface: explicitly stating functionality of an element you enable different [**Accessibility Features**](<doc:AccessibilityFeatures>) to correctly *recognise* the **purpose** of components and therefore give them an appropriate **accessible representation**. 

        ### For users
        Moreover, accessible description is used to portray user interfaces in **different forms** than the "regular" one. Unless elements are properly described, an abstract user of [**VoiceOver**](<doc:VoiceOver>) who relies on **semantic structure** of the interface *only* will never be able to **figure out what is happening on the screen of their device**.

        ### For API
        Absence of description also affects methods of both **direct** and **indirect selection**: an element without description cannot be *called by name* with [**Voice Control**](<doc:VoiceControl>) or *recognised* by [**Switch Control**](<doc:SwitchControl>) or [**Full Keyboard Access**](<doc:FullKeyboardAccess>) to enable **elements iteration**.

        ## What elements are considered described?
        To enable [Accessibility Features](<doc:AccessibilityFeatures>) work as intended for a particular *element* it has to have *certain properties* specified. Sometimes elements inherit such information **by default** — if they are of an *accessible class* (children of the standard `View`), but **most of the times we have to manually set properties for the items present on the screen to make it not only *function*, but *be pleasant* to use**.

        ### Description of accessible elements
        To remind yourself how Accessibility API decides whether the element is **accessible** (therefore can have **accessible description**), take a step back to [**Accessibility in Code**](<doc:AccessibilityInCode>).

        ### Accessibility attributes
        On iOS accessible description is *composed* of four **accessible attributes**: **Label**, **Value**, **Traits** and **Hint**. Once you are ready to meet them, let's go out for some **accessibly described** pizza.
    }

    @Section(title: "Label") {
        @ContentAndMedia {

            
            
            **Label** is the only **accessibility attribute** that **cannot be omitted**. In other words, **Label** is *required* to be specified for an element for it to be considered **accessible**.

            ### Identifying elements
            **Label** is the **main property** of the element's **accessible description**. It is essentially a unique identifier that is used by users to recognise this particular element as something singular. Represented by a **localised string**.
            
            ### Appropriate naming
            To be the best name for an element a **Label** must:
            - be as **short** as possible;
            - convey everything needed for users to be able to know **what this element is for**;
            - not contain any **detailed description** (to not double **Value**);
            - include any information referring to its **type** (to not double **Traits**);
            - be unique among the items of the current screen.
            
            Why? Let's figure out by choosing the pizza.

        }

        @Steps {
            @Step {
                The menu is a list of product cards. Each card is a complex element containing multiple interfacial elements, but our accessibility element is the whole card, because each of them represents a particular position in menu.

            }

            @Step {
                We need to choose which pizza we're going to order. How are we going to refer to the pizza of our choice? 

            }

            @Step {
                By its unique identifier, which in this case is "pizza name".
            }
            @Step {
            In this particular case it is **unreasonable** to separate the fact that it's "name" and its name into two different properties. Every element in this menu is pizza. It would be an **inconvenient experience** for users.
            }
            @Step {
                So just the name will be enough to distinguish this one out of the rest of the menu.
            }
        }
    }

    @Section(title: "Value") {
        @ContentAndMedia {    

            ### Details
            Another accessibility attribute is **Value**. Basically, this property is used to store any *additional information* about the element that is unnecessary for **Label** to contain, i.e. excessive for element's identification. Also a **localised string**.

        }

        @Steps {
            @Step {
                Ok, Hawaiian pizza. But how did we make this choice? We didn't pick pizza based on how its name sounds.
            }
            @Step {
                Accessibility **Value**. The first **optional** attribute on our path: if there is additional information about the element, but it's too much to be put in **Label**.
            }

            @Step {
                Product card as a **pattern** has a lot of **additional information** that tells customers *more* about the product. Do we just move *everything* there?
            }

            @Step {
                Nope. Well, yes, but not exactly. Accessibility **Value** serves one purpose: **to describe an element to users of [**VoiceOver**](<doc:AccessibilityFeatures>)**. Without an explicitly stated **Value** they can't access this information any other way.
            }
            
            @Step {
                Listening to an audial form (or touching Braille) of interfaces can be quiet exhausting. Moreover, interfaces may display information that is either **not valuable** at all (when an interface is unreasonably **cluttered**) or is only representable by **visual media**.
            }
            
            @Step {
                In our case there is this questionable **preview** of pizza. There is nothing wrong with willing to describe pizza, but we already have key **ingredients** listed in the card and it will be **sufficient** for this exact pizza **description**. 
            }
            
            @Step {
                No photo of pizza. Yes ingredients. What about **the price**?
            }
            
            @Step {
                Descriptions tend to get *wordy*. Manipulating customers attention, selling pizza to [**VoiceOver**](<doc:VoiceOver>) users should follow the same marketing strategies as to everyone else.
            }
            
            @Step {
                Whenever you have to put a lengthy description into **Value**, make sure you place its components **in the order of importance**. Some people would listen to the whole description to know whether there are pineapples in a pizza, but majority prefers to know the price first. Maybe it won't be pineapples to make a user not consider the pizza.
            }

        }

        @Section(title: "Label vs Value") {
            @ContentAndMedia {    
                ### Fine line between label and value
                To properly adapt an interface for various [**Accessibility Features**](<doc:AccessibilityFeatures>) one has to clearly differentiate between these two traits. For example, **Label** is heavily exploited by [`Voice Control`](<doc:VoiceControl>) and has to be **independent of unnecessary information** to avoid *ambiguity*. 
                
                In the meantime `Value` is that part of element's description that is changeable by [`AdjustableTrait`](<doc:AdjustableElements>)'s usage. 
            }
        }

        @Section(title: "Traits") {
            @ContentAndMedia {
                A value stored in `Traits` property points at the *functionality* of an element. By the default it is `none` and means that the element is plain and textual and there is nothing you can do about it. Same behaviour is implemented by explicitly stating `staticText` trait - it only exists for convenience so it is easier for humans to comprehend the role of the element. (Use it.)

                If an element has *more* than --none-- purely informative role **it has to be specified in this property** by stating one of [`UIAccessibilityTraits`](https://developer.apple.com/documentation/uikit/uiaccessibilitytraits) so both users and assistive technology know how to deal with this item.

                To see the complete list of traits available visit the [**Traits**](<doc:Traits>) tutorial - it has a living example of each them.

                @Video(source: traits-scroll)
            }

        @Steps {
                @Step {

                }

                @Step {

                }

                @Step {

                }

                @Step {

                }

                @Step {

                }

                @Step {
                
                }

                @Step {
               
                }
                
                @Step {
                
                }
                
                @Step {

                }

                @Step {
                
                }

                @Step {
                    
                }

                @Step {

                }
                
                @Step {

                }
        }
    }

    @Section(title: "Hint") {
        @ContentAndMedia {

            [`accessibilityHint`](https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint) is a *description* of what happens if the user *interacts* with an element. But there is a tricky moment.

            *Every* interactive element has its own `Hint` specified *by default*. The problem is that these hints are repetitive and **majority of `Accessibility Features` users turn it off** so there is very little chance that someone will ever see your *customised* hints. 

            The reason why you should customise the hints for your controls is that if there are [`Custom Actions`](<doc:Rotor>) a curious user may survey them in order to see **how *well* the application is adapted**.
        }

        @Steps {
            @Step {

            }

            @Step {

            }

            @Step {

            }
        }
    }

    @Section(title: "What now") {
        @ContentAndMedia {
            Congratulations! Now you know everything needed to fully **describe elements for *both* users and assistive technology** they use. 

            What about a little `quiz` to revise the topic? 🔎
        }

    }
        
    @Assessments {
        @MultipleChoice {
            Is this item accessible?

            @Choice(isCorrect: false) {
                Yes
                @Justification(reaction: "Try again!") {
                    text
                }
            }
              
            @Choice(isCorrect: true) {
                No
                @Justification(reaction: "That's right!") {
                    text
                }
            }
                    
            @Choice(isCorrect: false) {
                It is accessible, but the experience could be better
                @Justification(reaction: "Try again!") {
                    text
                }
            }
        }
    }
}
